<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>project_proposal</title><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .s1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 17pt; }
 .s2 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 h1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 p { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; margin:0pt; }
 .s3 { color: black; font-family:Monaco, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .a, a { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l1 {padding-left: 0pt;counter-reset: c1 1; }
 #l1> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 #l1> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l2 {padding-left: 0pt;counter-reset: c2 1; }
 #l2> li>*:first-child:before {counter-increment: c2; content: counter(c2, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 #l3 {padding-left: 0pt;counter-reset: c2 1; }
 #l3> li>*:first-child:before {counter-increment: c2; content: counter(c2, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l3> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 li {display: block; }
 #l4 {padding-left: 0pt; }
 #l4> li>*:first-child:before {content: "• "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
</style></head><body><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-top: 2pt;padding-left: 87pt;text-indent: 0pt;line-height: 112%;text-align: center;">Project Proposal: No-Wait Fork-Join Continuation Stealing Framework</p><p class="s2" style="padding-top: 11pt;padding-left: 87pt;text-indent: 0pt;line-height: 170%;text-align: center;">Zhengjia Cao (zhengjic) &amp; Jingzhi Zhang (jingzhi2) November 9, 2022</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l1"><li data-list-text="1"><h1 style="padding-left: 71pt;text-indent: -24pt;text-align: left;"><a name="bookmark0">Summary</a></h1><p style="padding-top: 11pt;padding-left: 47pt;text-indent: 0pt;line-height: 83%;text-align: justify;">We would like to implement a fork/join parallel framework with working stealing in C<span class="s3">++</span>. We will discuss the trade-off between implementation designs (<i>e.g.</i>, Child-stealing strategy vs. Continuation stealing, Different implementation of</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: justify;">distributed work queue, <i>etc.</i><a href="#bookmark7" class="a">) and measure their performance. On multi-core PSC machines, we would also like to implement the wait-free strand coordination method mentioned in Nowa </a>[1] and reproduce their benchmark against Cilk plus, TBB and OpenMP.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;"><a href="https://github.com/rivers-parallel/rivers-parallel.github.io" class="a" target="_blank">The URL of project web page is https://github.com/rivers-parallel/rivers- </a><a href="https://github.com/rivers-parallel/rivers-parallel.github.io" target="_blank">parallel.github.io.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2"><h1 style="padding-left: 71pt;text-indent: -24pt;text-align: left;"><a name="bookmark1">Background</a></h1><p style="padding-top: 9pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">For modern computer with multiple cores, scalability of parallelism is important. Fully strict Fork/Join model of concurrent run-time (like Cilk) can guarantee scalability by dynamically allocating and divide tasks until each task reaches a certain granularity. Once the subtasks have been created, threads can execute these subtasks in parallel until they’ve reached the barrier created by <i>Join </i>and continue to execute in sequential order. Program that requires heavy-workload computations can benefit from the model without too much overhead.</p><p style="padding-left: 47pt;text-indent: 14pt;text-align: justify;"><a href="#bookmark7" class="a">However, the scalability of most of current fully strict Fork/Join models suffer from the locking used in the system implementation. Nowa </a>[1] presents a wait-free continuation stealing approach to further scale the parallelism on machine with large number of processing units. We will follow the same design and transform hazardous race conditions and replace the requirement of using a lock with atomic counters.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3"><h1 style="padding-left: 71pt;text-indent: -24pt;text-align: left;"><a name="bookmark2">The challenge</a></h1><p style="padding-top: 9pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">There are mainly two challenges of implementing the framework: Firstly, we need to come up with an implementation that minimize the scheduling cost</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;"><span><img width="458" height="191" alt="image" src="project_proposal_files/Image_001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 87pt;text-indent: 0pt;text-align: center;">Figure 1: Illustration of a basic fork-join model</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">and consider different tradeoffs between different stealing policies and lock-free synchronization methods. Secondly, we need to design different scenarios and test the speedup of our fork-join framework against Cilk and OpenMP on dif- ferent hardware settings. We’d like to understand the results and analyze which tradeoff in design and implementation is responsible for the difference in per- formance.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4"><h1 style="padding-left: 71pt;text-indent: -24pt;text-align: left;"><a name="bookmark3">Resources</a></h1><p style="padding-top: 9pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">We will build our implementation of the framework. However, we will borrow some of the idea from existing implementations like :</p><ol id="l2"><li data-list-text="1."><p style="padding-top: 4pt;padding-left: 72pt;text-indent: -12pt;text-align: left;">Nowa Source Code: https://gitlab.cs.fau.de/i4/manycore/nowa/-/tree/master/</p></li><li data-list-text="2."><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -12pt;text-align: left;">Basic fork-join model: https://github.com/chaoran/fibril/</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="5"><h1 style="padding-left: 71pt;text-indent: -24pt;text-align: left;"><a name="bookmark4">Goals and deliverables</a></h1><ol id="l3"><li data-list-text="1."><p style="padding-top: 9pt;padding-left: 72pt;text-indent: -12pt;text-align: left;">Implement the basic fork-join model with distributed work queue</p></li><li data-list-text="2."><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -12pt;text-align: left;">Improve the framework to be wait-free and reproduce the result from nowa</p></li><li data-list-text="3."><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -12pt;text-align: left;">Test and compare the framework with other fork-join frameworks (e.g. Cilk) and discuss the tradeoffs.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="6"><h1 style="padding-left: 71pt;text-indent: -24pt;text-align: left;"><a name="bookmark5">Platform choice</a></h1><p style="padding-top: 7pt;padding-left: 47pt;text-indent: 0pt;line-height: 88%;text-align: justify;">From the perspective of software, we would like to use the co-routines in C<span class="s3">++ </span>20 to implement the continuation-stealing scheduler. As for hardware, our bot-</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: justify;">tleneck is CPU, so we will develop our code on GHC 8-core machines and do benchmark on PSC 128-core ones.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="7"><h1 style="padding-top: 2pt;padding-left: 71pt;text-indent: -24pt;text-align: left;"><a name="bookmark6">Schedule</a></h1></li></ol><ul id="l4"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 72pt;text-indent: -10pt;text-align: left;">Week 1: literature review; interface design</p></li><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -10pt;text-align: left;">Week 2: data structure implementation, mainly about distributed work queue</p></li><li data-list-text="•"><p style="padding-top: 7pt;padding-left: 72pt;text-indent: -10pt;text-align: left;">Week 3: basic work-stealing algorithm implementation</p></li><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -10pt;text-align: left;">Week 4: wait-free synchronization mechanism implementation</p></li><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -10pt;text-align: left;">Milestone Report Due: Wednesday, November 30th, 9:00am</p></li><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -10pt;text-align: left;">Week 5: benchmark; performance-based improvement; visualization</p></li><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -10pt;text-align: left;">Week 6: report writing; poster preparation</p></li><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -10pt;text-align: left;">Final Report Due: Saturday, December 17th, 11:59pm</p></li><li data-list-text="•"><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -10pt;text-align: left;">Poster Session: Sunday, December 18th, 1:00-4:00pm</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-top: 2pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">References</h1><p style="padding-top: 9pt;padding-left: 68pt;text-indent: -20pt;text-align: left;"><a name="bookmark7">[1] Florian Schmaus et al. “Nowa: A wait-free continuation-stealing concur- rency platform”. In: (2021), pp. 360–371.</a></p></body></html>
